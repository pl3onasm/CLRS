$\huge{\color{cadetblue}\text{Bubble sort}}$

<br/>

Bubble sort is a comparison sort that sorts an array $A[0:n-1]$ in ascending order by maintaining two subarrays: a sorted subarray $A[0:i]$ and an unsorted subarray $A[i+1:n-1]$. At each iteration, the boundary between the two subarrays is shifted one element to the right by moving the minimum element in the unsorted subarray $A[i+1:n-1]$ to the front of this subarray through a series of swaps so that the sorted subarray $A[0:i]$ can be extended by one element. Getting that minimum element to appear at index $i+1$ requires a pass through the unsorted subarray from $n-1$ down to $i+1$, swapping adjacent elements as necessary, i.e. if they form an inversion. This is also where the name comes from: as we keep swapping from the back to the front of the unsorted subarray, smaller elements keep "bubbling" to the front of that subarray, similar to bubbles rising to the surface of a liquid. It is also sometimes referred to as ${\color{darkseagreen} \text{sinking sort}}$, since larger elements "sink" to the bottom of the unsorted subarray as we move the boundary between the two subarrays to the right.

Bubble sort is an ${\color{darkseagreen} \text{in-place}}$ sort, meaning that it does not require any additional memory. It is also a ${\color{darkseagreen} \text{stable}}$ sort (since we only swap adjacent elements if they are out of order), meaning that elements with the same value will retain their relative order after sorting. It has a worst-case running time of ${\color{rosybrown}\mathcal{O}(n^2)}$, due to the nested loops, even if the array is already sorted. However, a small optimization can be made by keeping track of whether any swaps were made during a pass through the unsorted subarray. If no swaps were made, then the array is already sorted and the algorithm can terminate early. This reduces the best-case running time to $\mathcal{O}(n)$.

Note the difference with [selection sort](https://github.com/pl3onasm/CLRS/tree/main/algorithms/sorting/selection-sort), which also finds the minimum element at each step, but does so by performing a linear search for the minimum through the current unsorted subarray $A[i:n-1]$ to then swap the found minimum with $A[i]$ at the very end of each pass without any intermediate swaps, thus making it an unstable sort.

Implementation: [Bubble sort](https://github.com/pl3onasm/CLRS/tree/main/algorithms/sorting/bubble-sort/bubblesort.c)
